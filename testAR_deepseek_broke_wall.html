<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>AR Ball Destruction</title>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.0/dist/mindar-image-three.prod.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
        #ar-container {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        #ar-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
    </style>
</head>
<body>
    <div id="ar-container">
        <canvas id="ar-canvas"></canvas>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const mindarThree = new MindARThree({
                container: document.getElementById('ar-container'),
                imageTargetSrc: 'https://cdn.jsdelivr.net/npm/mind-ar@1.2.0/examples/image-tracking/assets/card-example/card.mind',
            });
            
            const { renderer, scene, camera } = mindarThree;
            
            // Настройка освещения
            const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
            scene.add(light);
            
            // Создание стены
            let wall = createWall();
            scene.add(wall);
            
            // Массив для хранения шаров
            const balls = [];
            
            // Массив для хранения осколков
            let fragments = [];
            
            // Обработчик клика по экрану
            renderer.domElement.addEventListener('click', (e) => {
                if (fragments.length > 0) return; // Не стрелять, если есть осколки
                
                const ball = createBall();
                scene.add(ball.mesh);
                balls.push(ball);
            });
            
            // Создание стены
            function createWall() {
                const wallGeometry = new THREE.BoxGeometry(1, 1, 0.1);
                const wallMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x8888ff,
                    transparent: true,
                    opacity: 0.8
                });
                const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                wall.position.set(0, 0, -2);
                return wall;
            }
            
            // Создание шара
            function createBall() {
                const radius = 0.1;
                const geometry = new THREE.SphereGeometry(radius, 32, 32);
                const material = new THREE.MeshStandardMaterial({ color: 0xff0000 });
                const mesh = new THREE.Mesh(geometry, material);
                
                // Начальная позиция - перед камерой
                mesh.position.set(0, 0, -0.5);
                
                // Направление движения - вперед
                const direction = new THREE.Vector3(0, 0, -1);
                
                return {
                    mesh,
                    direction,
                    speed: 0.2,
                    radius,
                    active: true
                };
            }
            
            // Создание осколков при разрушении стены
            function createFragments(wall) {
                const fragmentCount = 50;
                const fragments = [];
                
                // Получаем геометрию и материал стены
                const wallGeometry = wall.geometry;
                const wallMaterial = wall.material.clone();
                wallMaterial.transparent = true;
                
                // Создаем осколки
                for (let i = 0; i < fragmentCount; i++) {
                    const size = 0.1 + Math.random() * 0.1;
                    const geometry = new THREE.BoxGeometry(size, size, size);
                    
                    const fragment = new THREE.Mesh(geometry, wallMaterial);
                    
                    // Позиция осколка - случайная точка на стене
                    fragment.position.copy(wall.position);
                    fragment.position.x += (Math.random() - 0.5) * 1;
                    fragment.position.y += (Math.random() - 0.5) * 1;
                    
                    // Случайное вращение
                    fragment.rotation.set(
                        Math.random() * Math.PI,
                        Math.random() * Math.PI,
                        Math.random() * Math.PI
                    );
                    
                    // Случайное направление и скорость
                    fragment.userData.velocity = new THREE.Vector3(
                        (Math.random() - 0.5) * 0.2,
                        (Math.random() - 0.5) * 0.2,
                        (Math.random() - 0.5) * 0.2
                    );
                    
                    fragment.userData.angularVelocity = new THREE.Vector3(
                        Math.random() * 0.1,
                        Math.random() * 0.1,
                        Math.random() * 0.1
                    );
                    
                    fragments.push(fragment);
                    scene.add(fragment);
                }
                
                return fragments;
            }
            
            // Анимация
            const start = async () => {
                await mindarThree.start();
                renderer.setAnimationLoop(() => {
                    // Обновление шаров
                    for (let i = balls.length - 1; i >= 0; i--) {
                        const ball = balls[i];
                        if (!ball.active) continue;
                        
                        // Перемещение шара
                        ball.mesh.position.x += ball.direction.x * ball.speed;
                        ball.mesh.position.y += ball.direction.y * ball.speed;
                        ball.mesh.position.z += ball.direction.z * ball.speed;
                        
                        // Проверка столкновения со стеной
                        if (ball.mesh.position.distanceTo(wall.position) < 1) {
                            // Создание осколков
                            fragments = createFragments(wall);
                            
                            // Удаление стены
                            scene.remove(wall);
                            
                            // Удаление шара
                            scene.remove(ball.mesh);
                            ball.active = false;
                            balls.splice(i, 1);
                        }
                        
                        // Удаление шаров, улетевших далеко
                        if (ball.mesh.position.z < -5) {
                            scene.remove(ball.mesh);
                            balls.splice(i, 1);
                        }
                    }
                    
                    // Обновление осколков
                    for (let i = fragments.length - 1; i >= 0; i--) {
                        const fragment = fragments[i];
                        
                        // Перемещение осколка
                        fragment.position.x += fragment.userData.velocity.x;
                        fragment.position.y += fragment.userData.velocity.y;
                        fragment.position.z += fragment.userData.velocity.z;
                        
                        // Вращение осколка
                        fragment.rotation.x += fragment.userData.angularVelocity.x;
                        fragment.rotation.y += fragment.userData.angularVelocity.y;
                        fragment.rotation.z += fragment.userData.angularVelocity.z;
                        
                        // Гравитация
                        fragment.userData.velocity.y -= 0.01;
                        
                        // Удаление осколков, упавших ниже определенной точки
                        if (fragment.position.y < -3) {
                            scene.remove(fragment);
                            fragments.splice(i, 1);
                            
                            // Если все осколки исчезли, создаем новую стену
                            if (fragments.length === 0) {
                                wall = createWall();
                                scene.add(wall);
                            }
                        }
                    }
                    
                    renderer.render(scene, camera);
                });
            };
            
            start();
        });
    </script>
</body>
</html>